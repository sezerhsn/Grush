import type { EtherscanCustomApiCallOptions, EtherscanResponseBody, EtherscanVerifyArgs, LazyEtherscan } from "./etherscan.types.js";
import type { VerificationProvider, CreateEtherscanOptions, ResolveConfigOptions } from "./types.js";
import type { Dispatcher, DispatcherOptions } from "@nomicfoundation/hardhat-utils/request";
import type { ChainDescriptorsConfig, VerificationProvidersConfig } from "hardhat/types/config";
import type { EthereumProvider } from "hardhat/types/providers";
export declare const ETHERSCAN_PROVIDER_NAME: keyof VerificationProvidersConfig;
export declare const ETHERSCAN_API_URL = "https://api.etherscan.io/v2/api";
export declare class Etherscan implements VerificationProvider {
    readonly chainId: string;
    readonly name: string;
    readonly url: string;
    readonly apiUrl: string;
    readonly apiKey: string;
    readonly dispatcherOrDispatcherOptions?: Dispatcher | DispatcherOptions;
    readonly pollingIntervalMs: number;
    static resolveConfig({ chainId, networkName, chainDescriptors, verificationProvidersConfig, dispatcher, shouldUseCache, }: ResolveConfigOptions): Promise<CreateEtherscanOptions>;
    static create({ blockExplorerConfig, verificationProviderConfig, chainId, dispatcher, }: CreateEtherscanOptions): Promise<Etherscan>;
    static getSupportedChains(dispatcher?: Dispatcher, shouldUseCache?: boolean): Promise<ChainDescriptorsConfig>;
    constructor(etherscanConfig: {
        chainId: number;
        name?: string;
        url: string;
        apiUrl?: string;
        apiKey: string;
        dispatcher?: Dispatcher;
    });
    getContractUrl(address: string): string;
    isVerified(address: string): Promise<boolean>;
    verify({ contractAddress, compilerInput, contractName, compilerVersion, constructorArguments, }: EtherscanVerifyArgs): Promise<string>;
    pollVerificationStatus(guid: string, contractAddress: string, contractName: string): Promise<{
        success: boolean;
        message: string;
    }>;
    customApiCall(params: Record<string, unknown>, options?: EtherscanCustomApiCallOptions): Promise<EtherscanResponseBody>;
}
export declare class LazyEtherscanImpl implements LazyEtherscan {
    #private;
    constructor(provider: EthereumProvider, networkName: string, chainDescriptors: ChainDescriptorsConfig, verificationProvidersConfig: VerificationProvidersConfig);
    getChainId(): Promise<string>;
    getName(): Promise<string>;
    getUrl(): Promise<string>;
    getApiUrl(): Promise<string>;
    getApiKey(): Promise<string>;
    getContractUrl(address: string): Promise<string>;
    isVerified(address: string): Promise<boolean>;
    verify(args: EtherscanVerifyArgs): Promise<string>;
    pollVerificationStatus(guid: string, contractAddress: string, contractName: string): Promise<{
        success: boolean;
        message: string;
    }>;
    customApiCall(params: Record<string, unknown>, options?: EtherscanCustomApiCallOptions): Promise<EtherscanResponseBody>;
}
//# sourceMappingURL=etherscan.d.ts.map